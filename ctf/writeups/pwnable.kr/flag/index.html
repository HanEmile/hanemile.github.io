<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>emile.space</title>

  <style>
  * { word-wrap:break-word !important; font-family: monospace;
  margin: 0; padding: 0; }

/* light/darktheme specific foo */
@media (prefers-color-scheme: light) {
    html { background: #fff; color: #000; }
    a { color: #000; background: #fff; text-decoration: none;}
    a:not([href*="webring.xxiivv.com"]):hover, a:active { color: #fff; background: #000 }
    nav a:hover, a:active { color: #000; background: #fff }
    nav { margin: 1ex 0; background: #eee; }
    nav a { display:block; background: #eee; }
    h1 { margin: 3ex 0 1ex 0; width: 100%; background-color: #eee}
    h2 { margin: 2ex 0 1ex 0; width: 100%; background-color: #eee}
    h3 { margin: 1ex 0 1ex 0; width: 100%; /*background-color: #eee*/}
    .code { border-left: 1px solid #000; padding-left: 1ex; }
}
@media (prefers-color-scheme: dark) {
    html { background: #000; color: #fff; }
    a { color: #fff; background: #000; text-decoration: none; }
    a:not([href*="webring.xxiivv.com"]):hover, a:active { color: #000; background: #fff }
    nav a:hover, a:active { color: #fff; background: #000 }
    nav { margin: 1ex 0; background: #fff; }
    nav a { display:block; background: #fff; }
    h1 { margin: 3ex 0 1ex 0; width: 100%; background-color: #fff}
    h2 { margin: 2ex 0 1ex 0; width: 100%; background-color: #fff}
    h3 { margin: 1ex 0 1ex 0; width: 100%; /*background-color: #fff*/}
    .code { border-left: 1px solid #fff; padding-left: 1ex; }
    .webring { -webkit-filter: invert(100%); filter: invert(100%); }
}

/* settings for mobile devices*/
@media only screen and (max-width: 768px) {
  body { margin: 1ex; width: calc(100% - 2ex) !important; }
  img { max-width: 100% !important; max-height: 400px; }
}
img { max-width: 100ex; max-height: 400px; }

body { margin-left: auto; margin-right: auto; margin-top: 1ex; margin-bottom: 1ex; width: 100ex; }


.webring { align: right; }
a .webring { float: right; }

/* display local links using [] and external links using {} */
body pre a:not([href*="webring.xxiivv.com"]):before { content: "["; }
body pre a:not([href*="webring.xxiivv.com"]):after { content: "]"; }
a[href*="//"]:not([href*="emile.space"]):not([class*="icon"]):before {
  content: '{';
}
a[href*="//"]:not([href*="emile.space"]):not([class*="icon"]):after {
  content: '}';
}


ul { list-style-type: none; }

/* navigation bar magic */
nav * { color: #000; }
nav ul { list-style: none; position: relative; display: inline-block; }
nav ul li { display:inline-block; }
nav ul ul { display: none; position: absolute; border: 1px solid #000; background-color: #ff0; }
nav ul ul li { width: 100%; padding-right: 1ex; float:none; display:list-item; position: relative; }
nav + ul li { display: inline-block;}

/* only display the hover dropdown on non-mobile devices */
@media only screen and (min-width: 768px) {
  nav ul li:hover a + ul { display: inherit; white-space: nowrap; }
}

/* nav bar spacing char */
nav ul li > a::after { content: " /"; }
nav ul li > a:only-child::after { content: ""; }
nav ul li:last-of-type a::after { content: ""; }

h1 a, h2 a, h3 a { padding-right: 1ex; }

pre { white-space: pre-wrap; }

/* display the list of folders in the current one as a vertical list, if the
 * .vert class is present */
nav + ul.vert li { display: block; }

.w-100 { width: 100%; }


  </style>
</head>
    
<body>
  <header>
    <a href="/">emile.space</a>
  </header>
  <nav>
    <ul>
        <li>
            <a href="/ctf">ctf</a>
            <ul>
                <li><a href="/about">about/</a></li>
                <li><a href="/blog">blog/</a></li>
                <li><a href="/events">events/</a></li>
                <li><a href="/files">files/</a></li>
                <li><a href="/projects">projects/</a></li>
                <li><a href="/publications">publications/</a></li>
                <li><a href="/sport">sport/</a></li>
                <li><a href="/talks">talks/</a></li>
                <li><a href="/workshops">workshops/</a></li>
            </ul>
        </li>
        <li>
            <a href="/ctf/writeups">writeups</a>
            <ul>
                <li><a href="/ctf/hosted-events">hosted-events/</a></li>
                <li><a href="/ctf/resources">resources/</a></li>
                <li><a href="/ctf/teams">teams/</a></li>
            </ul>
        </li>
        <li>
            <a href="/ctf/writeups/pwnable.kr">pwnable.kr</a>
            <ul>
                <li><a href="/ctf/writeups/2019">2019/</a></li>
                <li><a href="/ctf/writeups/2020">2020/</a></li>
                <li><a href="/ctf/writeups/2021">2021/</a></li>
            </ul>
        </li>
        <li>
            <a href="/ctf/writeups/pwnable.kr/flag">flag</a>
            <ul>
                <li><a href="/ctf/writeups/pwnable.kr/bof">bof/</a></li>
                <li><a href="/ctf/writeups/pwnable.kr/collision">collision/</a></li>
                <li><a href="/ctf/writeups/pwnable.kr/fd">fd/</a></li>
            </ul>
        </li>
    </ul>
  </nav>
  <ul>
  </ul><pre></pre>
            <span id="flag"></span>
            <h1><a href="#flag">flag</a></h1>
            <pre>
</pre><pre class="code">Papa brought me a packed present! let's open it.</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">Download : http://pwnable.kr/bin/flag</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">This is reversing task. all you need is binary</pre><pre>


</pre>
            <span id="what-is-given"></span>
            <h2><a href="#what-is-given">What is given?</a></h2>
            <pre>

We only get a binary.


</pre>
            <span id="understanding-the-source"></span>
            <h2><a href="#understanding-the-source">Understanding the source</a></h2>
            <pre>
There is no source, wait, there is! The binary itself. Altough the binary might not look like sourcecode (it really isn't), it contains instructions for our CPU to execute. Now we're only given this binary, so we'll have to do something with it...

Starting off, instead of directly jumping into some crazy tools, I like to get an overview of the binary by looking at the strings contained withing it. Yes, you read that right. For this, simply executing string -n 16 is enough to get some information that might give us some understanding on what we've got in front of us:


</pre><pre class="code">root@a80be868eac7:/pwn# strings -n 16 flag | nl</pre><pre>
</pre><pre class="code">     1	'''' (0h''''HPX`</pre><pre>
</pre><pre class="code">     2	FFFF|vpjFFFFd^XR</pre><pre>
</pre><pre class="code">        </pre><pre>
</pre><pre class="code">        ...</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">    21	&9223372036854775807L`</pre><pre>
</pre><pre class="code">    22	PROT_EXEC|PROT_WRITE failed.</pre><pre>
</pre><pre class="code">    23	$Info: This file is packed with the UPX executable packer http://upx.sf.net $</pre><pre>
</pre><pre class="code">    24	$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $</pre><pre>
</pre><pre class="code">    25	GCC: (Ubuntu/Linaro 4.6.3-1u)#</pre><pre>
</pre><pre class="code">    26	DEH_FRAME_BEGINf</pre><pre>
</pre><pre class="code">    27	_PRETTY_FUNCT0Na</pre><pre>


Now this might look pretty crazy, but there is information in there: The most important being the one in line 23: This file is packed with the UPX executable packer. For looking at the content of the binary, me must first unpack it using UPX, the Ultimate Packer for eXecutables:


</pre><pre class="code">root@a80be868eac7:/pwn# upx -d flag</pre><pre>
</pre><pre class="code">                       Ultimate Packer for eXecutables</pre><pre>
</pre><pre class="code">                          Copyright (C) 1996 - 2020</pre><pre>
</pre><pre class="code">UPX 3.96        Markus Oberhumer, Laszlo Molnar & John Reiser   Jan 23rd 2020</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">        File size         Ratio      Format      Name</pre><pre>
</pre><pre class="code">   --------------------   ------   -----------   -----------</pre><pre>
</pre><pre class="code">    883745 &lt-    335288   37.94%   linux/amd64   flag</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">Unpacked 1 file.</pre><pre>


Having unpacked the file, we can look around it it using <a href="https://github.com/radareorg/radare2">radare2</a>:


</pre><pre class="code">root@a80be868eac7:/pwn# r2 flag</pre><pre>
</pre><pre class="code"> -- ==1337== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</pre><pre>
</pre><pre class="code">[0x00401058]></pre><pre>


Don't worry, the text after opening radare just displays some joke.

Now that you've got the binary open in radare, you've got to tell radare to analyze it. As radare is operated a lot through commands consisting of letter combinations, you'll probably find it weird. That's ok, that's totally normal and it'll stay that way for a while. In order to get familliar with commands, you can add the suffix ? and radare will present you with options. For example, as we want to analyze, we'll probably want to find out how radare can analyze. For this, we can use the following command and read the output:


</pre><pre class="code">[0x00401058]> a?</pre><pre>
</pre><pre class="code">Usage: a  [abdefFghoprxstc] [...]</pre><pre>
</pre><pre class="code">| a                  alias for aai - analysis information</pre><pre>
</pre><pre class="code">| a*                 same as afl*;ah*;ax*</pre><pre>
</pre><pre class="code">| aa[?]              analyze all (fcns + bbs) (aa0 to avoid sub renaming)</pre><pre>
</pre><pre class="code">| a8 [hexpairs]      analyze bytes</pre><pre>
</pre><pre class="code">| ab[?]              analyze basic block</pre><pre>
</pre><pre class="code">| ac[?]              manage classes</pre><pre>
</pre><pre class="code">| aC[?]              analyze function call</pre><pre>
</pre><pre class="code">| aCe[?]             same as aC, but uses esil with abte to emulate the function</pre><pre>
</pre><pre class="code">| ad[?]              analyze data trampoline (wip)</pre><pre>
</pre><pre class="code">| ad [from] [to]     analyze data pointers to (from-to)</pre><pre>
</pre><pre class="code">| ae[?] [expr]       analyze opcode eval expression (see ao)</pre><pre>
</pre><pre class="code">| af[?]              analyze functions</pre><pre>
</pre><pre class="code">| aF                 same as above, but using anal.depth=1</pre><pre>
</pre><pre class="code">| ag[?] [options]    draw graphs in various formats</pre><pre>
</pre><pre class="code">| ah[?]              analysis hints (force opcode size, ...)</pre><pre>
</pre><pre class="code">| ai [addr]          address information (show perms, stack, heap, ...)</pre><pre>
</pre><pre class="code">| aj                 same as a* but in json (aflj)</pre><pre>
</pre><pre class="code">| aL                 list all asm/anal plugins (e asm.arch=?)</pre><pre>
</pre><pre class="code">| an [name] [@addr]  show/rename/create whatever flag/function is used at addr</pre><pre>
</pre><pre class="code">| ao[?] [len]        analyze Opcodes (or emulate it)</pre><pre>
</pre><pre class="code">| aO[?] [len]        Analyze N instructions in M bytes</pre><pre>
</pre><pre class="code">| ap                 find prelude for current offset</pre><pre>
</pre><pre class="code">| ar[?]              like 'dr' but for the esil vm. (registers)</pre><pre>
</pre><pre class="code">| as[?] [num]        analyze syscall using dbg.reg</pre><pre>
</pre><pre class="code">| av[?] [.]          show vtables</pre><pre>
</pre><pre class="code">| ax[?]              manage refs/xrefs (see also afx?)</pre><pre>


Here, radare lists all possible commands that start with a. We'll want to get an understanding of the binary, or to be more precise, an understanding of what functions the binary consists of. For this, we can use the af command that will analyze the functions, so that we can use other commands to view information regarding them.

You can execute the af? command and look at the options that radare offers for analyzing functions. There's a lot, I'll use afr for analyzing the functions recursively. This should provide us with some information, or at least some information on what functions exist.

Now as the binary contains debug information, for example the name of the functions, radare can use this to our advantage. If you want to view the dissassembly of the main function, you can use the pd command (print dissassembly) using the sym.main argument:


</pre><pre class="code">[0x00401058]> s sym.main</pre><pre>
</pre><pre class="code">[0x00401164]> pd</pre><pre>
</pre><pre class="code">            ;-- main:</pre><pre>
</pre><pre class="code">            0x00401164      55             push rbp</pre><pre>
</pre><pre class="code">            0x00401165      4889e5         mov rbp, rsp</pre><pre>
</pre><pre class="code">            0x00401168      4883ec10       sub rsp, 0x10</pre><pre>
</pre><pre class="code">            0x0040116c      bf58664900     mov edi, str.I_will_malloc___and_strcpy_the_flag_there._take_it. ; 0x496658 ; "I will malloc() and strcpy the flag there. take it."</pre><pre>
</pre><pre class="code">            0x00401171      e80a0f0000     call sym.puts</pre><pre>
</pre><pre class="code">            0x00401176      bf64000000     mov edi, 0x64               ; 'd' ; 100</pre><pre>
</pre><pre class="code">            0x0040117b      e850880000     call sym.malloc</pre><pre>
</pre><pre class="code">            0x00401180      488945f8       mov qword [rbp - 8], rax</pre><pre>
</pre><pre class="code">            0x00401184      488b15e50e2c.  mov rdx, qword [obj.flag]   ; [0x6c2070:8]=0x496628 str.UPX...__sounds_like_a_delivery_service_:_ ; "(fI"</pre><pre>
</pre><pre class="code">            0x0040118b      488b45f8       mov rax, qword [rbp - 8]</pre><pre>
</pre><pre class="code">            0x0040118f      4889d6         mov rsi, rdx</pre><pre>
</pre><pre class="code">            0x00401192      4889c7         mov rdi, rax</pre><pre>
</pre><pre class="code">            0x00401195      e886f1ffff     call 0x400320</pre><pre>
</pre><pre class="code">            0x0040119a      b800000000     mov eax, 0</pre><pre>
</pre><pre class="code">            0x0040119f      c9             leave</pre><pre>
</pre><pre class="code">            0x004011a0      c3             ret</pre><pre>
</pre><pre class="code">            0x004011a1      90             nop</pre><pre>
</pre><pre class="code">            0x004011a2      90             nop</pre><pre>
</pre><pre class="code">            0x004011a3      90             nop</pre><pre>
</pre><pre class="code">            0x004011a4      90             nop</pre><pre>
</pre><pre class="code">            0x004011a5      90             nop</pre><pre>


Now radare prints a lot of information here, more than we'd actually like, but that's all right for now. For your understanding: the first column is the address of the instruction displayed, the second column the raw instruction and the third column contains the dissassembled instruction for us to read (reading the second column isn't really nice).

Reversing is mainly the art of starting from the bottom and working your way up, so known what to look out for is great. In radare, function calls are highlighted (it depends on how your terminal is setup, but the color of the call ... calls should be somehow different). Using these, you can get a quite nice understanding of what is happening, assuming that you've got names for the calls. In out case, we have! Let's go through the main function a few lines at a time, so you can get an understanding of what is happening:


</pre><pre class="code">           ;-- main:</pre><pre>


This is just a comment radare inserted for us to tell us: this is the "main" function. Useful, but not doing much...


</pre><pre class="code">            0x00401164      55             push rbp</pre><pre>
</pre><pre class="code">            0x00401165      4889e5         mov rbp, rsp</pre><pre>


Now this is a classic. When functions are called, a new stack frame is created. For this, information on the "old" parent frame needs to be stored somewhere. This is done like this: the old base pointer rbp is pushed onto the stack and the value of the old stack pointer is moved into the base pointer, "moving" it up, so that the base of the new frame lies above the top value of the last frame. (I'd recommend you to read the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">x86 calling conventions</a> Wikipedia article and/or some blogposts on how function are called in assembler/c for understanding this topic, as it is really fundamental for everything to come).


</pre><pre class="code">            0x00401168      4883ec10       sub rsp, 0x10</pre><pre>


as soon as we've created the new stack frame, we'll subtract 0x10 from the frame pointer moving it "up". Now this might sound weird at first, but think about how the stack is located in memory, in which direction it "grows" and what the implications of this action is. If we're going to write some local arguments somewhere, we need somewhere to store them. With this operation, we've just made some space for this to happen.


</pre><pre class="code">            0x0040116c      bf58664900     mov edi, str.I_will_malloc___and_strcpy_the_flag_there._take_it. ; 0x496658 ; "I will malloc() and strcpy the flag there. take it."</pre><pre>
</pre><pre class="code">            0x00401171      e80a0f0000     call sym.puts</pre><pre>


And now, our first call. I've grouped this into two lines, as they belong together quite fundamentally. The first line moves the string I will malloc() and strcpy the flag there. take it. into the edi register (or to be more precise, a pointer to the string, as we can't fit the whole string into that small register). For understanding why this is insteresting and what happens next, you need to understand how function arguments are passed in 64-bit x86 assembler: The first 6 arguments are passed via registers (rdi, rsi, rdx, rcx, r9, r8 respectively), if there are more, they are pushed onto the stack. (Sidenote: in 32-bit x86 assembler, all arguments are pushed onto the stack). This means that in out case here, we insert the string into the rdi register that is the first argument used when a function is called. Looking into the next line, tada, a function is called!. The function sym.puts is called (the function is just called puts, the sym is inserted there by radare indicating that this information is taken from the symbols table). Reading the puts manpage (man puts) enlightens us on what puts does: it prints the first argument it gets to stdout.

And that's pretty much it! These two lines prepared a string to be prineted by inserting a pointer to it into the correct register and then called a function printing the string.

Let's go on...


</pre><pre class="code">            0x00401176      bf64000000     mov edi, 0x64               ; 'd' ; 100</pre><pre>
</pre><pre class="code">            0x0040117b      e850880000     call sym.malloc</pre><pre>


Same game: we're inserting the value 0x64 into the edi register (edi is just the lower 32 bits of the rdi register (e prefix = 32 bit, r prefix = 64 bit)). After inserting the value into the register, we can call the malloc function which will allocate some memory for us. In order to use this memory, we can use the return value that is stored in the rax register (just memorize this, put a post it on your screen or so).

Having called malloc, the string printed before spoilers a bit, but let's look at what's happening now...


</pre><pre class="code">            0x00401180      488945f8       mov qword [rbp - 8], rax</pre><pre>
</pre><pre class="code">            0x00401184      488b15e50e2c.  mov rdx, qword [obj.flag]   ; [0x6c2070:8]=0x496628 str.UPX...__sounds_like_a_delivery_service_:_ ; "(fI"</pre><pre>
</pre><pre class="code">            0x0040118b      488b45f8       mov rax, qword [rbp - 8]</pre><pre>


This looks quite weird at first, let's try to understand it (I've removed the long comment bellow):

- mov qword [rbp - 8], rax
  - this moves the value stored in rax (the pointer to the memory we've allocated before) into the value stored at [rbp - 8]. It might be interesting what exactly is here, but let's first look at what's happening next.
- mov rdx, qword [obj.flag]
  - the obj.flag quad word (qword) is moved into the rdx register. Now this is obviously our flag. We can print the value of this object in radare using the pf S @obj.flag command (I'd highly suggest you look at the output of the following commands: p?, pf?, pf??). This prints out the flag, so this challenge is actually done here, but for the sake of completeness, let's finish going through this function, as you might still learn something.
- mov rax, qword [rbp - 8]
  - Now this moves back the value temporarily stored at rbp - 8 into the rax register. Not really interesting, just the use of a local variable.

</pre><pre class="code">            0x0040118f      4889d6         mov rsi, rdx</pre><pre>
</pre><pre class="code">            0x00401192      4889c7         mov rdi, rax</pre><pre>
</pre><pre class="code">            0x00401195      e886f1ffff     call 0x400320</pre><pre>


We've got another function call here, as you can see. The arguments are populated using the values stored in the rdx and rax registers, but I'm not really in the mood for looking into this function, as we've already found the flag.


</pre><pre class="code">            0x0040119a      b800000000     mov eax, 0</pre><pre>
</pre><pre class="code">            0x0040119f      c9             leave</pre><pre>
</pre><pre class="code">            0x004011a0      c3             ret</pre><pre>


We're now getting to the end of the function. As when calling a function, when leaving a function, there are a few things that need to be done:

inserting a value into eax allows us to define a return value, as the caller will expect a value there indicating the return value
restoring the old stack frame (just lookup what leave and ret do)

</pre><pre class="code">            0x004011a1      90             nop</pre><pre>
</pre><pre class="code">            0x004011a2      90             nop</pre><pre>
</pre><pre class="code">            ...</pre><pre>


The rest if filled with nops. I don't know why, but it works.


</pre>
            <span id="exploiting"></span>
            <h2><a href="#exploiting">Exploiting</a></h2>
            <pre>
Well, no exploiting in this challenge, just reversing...
<br>
    <br>
    <br>
    </pre>
<a href="https://lieu.cblgh.org/" target="_blank" rel="noopener" class="icon"><img class="webring" src="/lieu.svg" alt="lieu webring search engine" height="32px"/></a>
<a href="https://webring.xxiivv.com/#emile" target="_blank" rel="noopener" class="icon"><img class="webring" src="/webring.svg" alt="XXIIVV webring" height="32px"/></a>
    <pre>
emile - 1667082414.860164s
</body>
</html>
    <pre>